#include <ros/ros.h>
#include <Eigen/Eigen>
#include <bezier_test/bezier_predict.h>
#include <geometry_msgs/PoseStamped.h>
#include <visualization_msgs/Marker.h>

#define Max_L 30
#define Max_past 3000
#define _PREDICT_SEG 50

class BezierTraj   {
    private:
        ros::Publisher pub_pretraj;
        ros::Publisher pub_pasttraj;
        ros::Subscriber sub_uav_pose;
        ros::Timer replan_timer;

        Bezierpredict tgpredict;

        std::vector<Eigen::Vector4d> target_detect_list;
        std::vector<Eigen::Vector4d> past_detect_list;

        double replan_frequency = 12.0;
        // double last_rcvtime;

    public:
        BezierTraj(ros::NodeHandle& nh)    {
            pub_pretraj = nh.advertise<visualization_msgs::Marker>("bezier/vis_pre_traj", 1);
            pub_pasttraj = nh.advertise<visualization_msgs::Marker>("bezier/vis_past_traj", 1);
            sub_uav_pose = nh.subscribe<geometry_msgs::PoseStamped>("mavros/local_position/pose", 10, &BezierTraj::get_pose,this);
            replan_timer = nh.createTimer(ros::Duration(1/replan_frequency), &BezierTraj::predict, this);
        }

        void get_pose(const geometry_msgs::PoseStamped msg) {
            static bool flag_tar = false;
            static bool flag_past = false;
            Eigen::Vector4d state(msg.pose.position.x, msg.pose.position.y, msg.pose.position.z, msg.header.stamp.toSec());
            if(!flag_tar)   {
                target_detect_list.push_back(state);
                if(target_detect_list.size() >= Max_L){
                    flag_tar = 1;
                }
            }
            else{
                target_detect_list.erase(target_detect_list.begin());
                target_detect_list.push_back(state);
            }

            if(!flag_past)   {
                past_detect_list.push_back(state);
                if(past_detect_list.size() >= Max_past){
                    flag_past = 1;
                }
            }
            else{
                past_detect_list.erase(past_detect_list.begin());
                past_detect_list.push_back(state);
            }
            
            visualize_past(past_detect_list);
            // last_rcvtime = ros::Time::now().toSec();
        }

        void predict(const ros::TimerEvent& event)  {
            static std::vector<Eigen::Matrix<double,6,1>> predict_state_list;   //pos(3) + vel(3)
            static std::vector<Eigen::Vector3d> Sample_list;
            if(target_detect_list.size() < Max_L)   return;

            int bezier_flag = tgpredict.TrackingGeneration(5, 5, target_detect_list);
            if(bezier_flag == 0){
                predict_state_list = tgpredict.getStateListFromBezier(_PREDICT_SEG);
                Sample_list = tgpredict.SamplePoslist_bezier(_PREDICT_SEG);
            }
            else{
                ROS_WARN("bezier predict error");
            }
            if(predict_state_list.size() < 1) {
                ROS_ERROR("Bezier predict failed");    
                return;
            }

            visualize_sample(Sample_list);
        }

        void visualize_sample(std::vector<Eigen::Vector3d> poslist) {
            visualization_msgs::Marker _pred_vis;
            _pred_vis.header.stamp       = ros::Time::now();
            _pred_vis.header.frame_id    = "map";
            _pred_vis.ns = "/tracking_pred";
            _pred_vis.type = visualization_msgs::Marker::SPHERE_LIST;
            _pred_vis.action = visualization_msgs::Marker::ADD;
            _pred_vis.scale.x = 0.1;
            _pred_vis.scale.y = 0.1;
            _pred_vis.scale.z = 0.1;
            _pred_vis.pose.orientation.x = 0.0;
            _pred_vis.pose.orientation.y = 0.0;
            _pred_vis.pose.orientation.z = 0.0;
            _pred_vis.pose.orientation.w = 1.0;
            _pred_vis.color.a = 1.0;
            _pred_vis.color.r = 0.0;
            _pred_vis.color.g = 1.0;
            _pred_vis.color.b = 0.0;//black
            Eigen::Vector3d pos;
            geometry_msgs::Point pt;
            for(unsigned int i=0;i<poslist.size();i++){
                pos  = poslist[i];
                pt.x = pos(0);
                pt.y = pos(1);
                pt.z = pos(2);
                _pred_vis.points.push_back(pt);
            }
            pub_pretraj.publish(_pred_vis);
        }

        void visualize_past(std::vector<Eigen::Vector4d> poslist) {
            visualization_msgs::Marker _pred_vis;
            _pred_vis.header.stamp       = ros::Time::now();
            _pred_vis.header.frame_id    = "map";
            _pred_vis.ns = "/tracking_pred_past";
            _pred_vis.type = visualization_msgs::Marker::SPHERE_LIST;
            _pred_vis.action = visualization_msgs::Marker::ADD;
            _pred_vis.scale.x = 0.1;
            _pred_vis.scale.y = 0.1;
            _pred_vis.scale.z = 0.1;
            _pred_vis.pose.orientation.x = 0.0;
            _pred_vis.pose.orientation.y = 0.0;
            _pred_vis.pose.orientation.z = 0.0;
            _pred_vis.pose.orientation.w = 1.0;
            _pred_vis.color.a = 1.0;
            _pred_vis.color.r = 1.0;
            _pred_vis.color.g = 0.0;
            _pred_vis.color.b = 0.0;//black
            Eigen::Vector4d pos;
            geometry_msgs::Point pt;
            for(unsigned int i=0;i<poslist.size();i++){
                pos  = poslist[i];
                pt.x = pos(0);
                pt.y = pos(1);
                pt.z = pos(2);
                _pred_vis.points.push_back(pt);
            }
            pub_pasttraj.publish(_pred_vis);
        }
};

int main(int argc, char **argv) {

    ros::init(argc, argv, "predict_test");
    ros::NodeHandle nh_;
    BezierTraj BTObject(nh_);

    ros::spin();

    return 0;
}
        
